"""
File contains class used for feature selection.

Author: Dominik Macko
"""

from typing import Union, Optional, List, Dict

import numpy as np
import pandas as pd
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_selection import VarianceThreshold
from boruta import BorutaPy

class FeatureSelectionTransformer(BaseEstimator, TransformerMixin):
    """Feature selection transformer that uses variance threshold and Boruta.
    
    https://towardsdatascience.com/boruta-explained-the-way-i-wish-someone-explained-it-to-me-4489d70e154a
    """
    
    def __init__(self,
                 variance_threshold: float=0.995 * (1 - 0.995),
                 seed: int =42,
                 n_jobs: int=-1,
                 n_estimators: int=200,
                 verbose: int=1,
                 max_depth: int=5,
                 max_iter: int=50,
                 use_weak_boruta_support: bool=True
        ):
        """Initializes feature selection transformer.
        
        variance_threshold - specifies cutoff threshold for variance
        seed - random state seed
        n_jobs - cores to use, -1 can be used for maximum, default -1
        n_estimators - number of trees to use, default 200
        max_depth - max depth of trees, default 5
        max_iter - maximum iterations of Boruta, default 50
        use_weak_boruta_support - specifies whether selection should be conservative and weaker features kept
        
        note: to not keep features with the same value in 99.5% of samples use variance_threshold=0.995 * (1 - 0.995)
        """
        
        self._pipeline: Pipeline = Pipeline(
            [
                ("variance_threshold", VarianceThreshold(variance_threshold)),
                ("boruta", BorutaPy(
                    RandomForestClassifier(
                        n_estimators=n_estimators, 
                        n_jobs=n_jobs,
                        max_depth=max_depth,
                        class_weight="balanced"
                    ),
                    random_state=seed, 
                    verbose=verbose, 
                    max_iter=max_iter)
                )
            ]
        )
        self._use_weak_boruta_support: bool = use_weak_boruta_support 
            
        
    def fit(self,
            X: pd.DataFrame,
            y: Union[pd.DataFrame, pd.Series]
           ) -> "FeatureSelectionTransformer":
        """Fits transformer to given training data."""
        
        self._pipeline.fit(X, y.values.ravel())
        self._fit_columns = X.columns
        return self
        
    def transform(self,
                  X: pd.DataFrame,
                  y: Optional[Union[pd.DataFrame, pd.Series]]=None
                 ) -> pd.DataFrame:
        """Transforms given training data, must be used only after being fit."""
        
        return X.loc[:, self._get_variance_threshold_mask()].loc[:, self._get_boruta_mask()]
    
    def selected_columns(self) -> List[str]:
        """Gets list of selected columns."""
        
        return [*self._fit_columns[self._get_variance_threshold_mask()][self._get_boruta_mask()]]
        
    def _get_variance_threshold_mask(self) -> np.array:
        """Gets variance threshold mask."""
        
        return self._pipeline["variance_threshold"].get_support()
    
    def _get_boruta_mask(self) -> np.array:
        """Gets boruta support mask based on whether weak boruta support should be included."""
        
        if not self._use_weak_boruta_support:
            return self._pipeline["boruta"].support_ 
        return self._pipeline["boruta"].support_weak_ | self._pipeline["boruta"].support_

